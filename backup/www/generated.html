<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!-- Component CSS -->
    <style>
      /* player-css */
      .player-color {
      	background-color : green;
      }
      /* extra-gol */
      #board input[type="checkbox"] {
      		appearance: none;
      		width: 100%;
      		aspect-ratio: 1;
      		display: block;
      		margin: 0;
      	}
      	#board input[type="checkbox"]:checked {
      		background-color: black;
      	}
      	#board table {
      		border-collapse: collapse;
      		table-layout: fixed;
      		width: 50vw;
      		height: 50vw;
      	}
      	#board td {
      		border: 1px solid #999;
      		aspect-ratio: 1;
      		position: relative;
      		padding: 0;
      	}
      	body {
      		display: grid;
      		grid-template: "left right";
      		height: 100vh;
      		overflow: hidden;
      	}
      	main {
      		grid-area: left;
      		padding: 1em;
      	}
      	.source {
      		grid-area: right;
      		display: block;
      		font-family: monospace;
      		white-space: pre;
      		height: 100%;
      		overflow: auto;
      		background-color: #0F0F0F;
      		color: #FEFEFE;
      	}
    </style>
    <!-- /Component CSS -->
    <!-- Page CSS -->
    <style>
      /* mainGrid */
      .grid-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        grid-auto-rows: minmax(100px, auto);
      }
      
      .column-left {
          grid-column: 1;
      	background-color: AliceBlue ;  
      }
      
      .column-center {
          grid-column: 2;
      	background-color: AliceBlue ;  
      }
      
      .column-right {
          grid-column: 3;
      	background-color: AliceBlue ;  
      }
    </style>
    <!-- /Page CSS -->
    <!-- Head HTML -->
    <!-- dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <!-- signals -->
    <script type="module">
    	import { signal, effect } from 'https://cdn.jsdelivr.net/gh/poef/signals/src/signals.mjs'
    </script>
    <!-- /Head HTML -->
    <script>
      var simplyDataApi = {};
      var simplyApp = {};
      window.addEventListener("simply-content-loaded", function() {
        simply.bind = false;
        /* Raw API */
        var simplyRawApi = {
          "life" : "none",
          "player" : function () {
            let player = {
          		"playerColor":"green",
            }
          }
        };
        /* End of Raw API */
        /* Data API */
        simplyDataApi = {
          
        };
        /* End of Data API */
        simplyApp = simply.app({
          /* Actions */
          actions: {
            "launch" : function () {
                        // clear old chart when 'plot' is clicked
                        document.getElementById('board').innerHTML = ""
            
                        // Declare the chart dimensions and margins.
                        const width = 320;
                        const height = 320;
                        const marginTop = 0;
                        const marginRight = 0;
                        const marginBottom = 0;
                        const marginLeft = 0;
            
                        // Declare the x (horizontal position) scale.
                        const x = d3.scaleUtc()
                            .domain(0, width)
                            .range([marginLeft, width - marginRight]);
            
                        // Declare the y (vertical position) scale.
                        const y = d3.scaleLinear()
                            .domain([0, height])
                            .range([height - marginBottom, marginTop]);
            
                        // Create the SVG container.
                        const svg = d3.create("svg")
                            .attr("width", width)
                            .attr("height", height);
            
                        // Add the x-axis.
                        svg.append("g")
                            .attr("transform", `translate(0,${height - marginBottom})`)
                            .call(d3.axisBottom(x));
            
                        // Add the y-axis.
                        svg.append("g")
                            .attr("transform", `translate(${marginLeft},0)`)
                            .call(d3.axisLeft(y));
            
                        const dataset = simply.app.life
            
            
                        svg.selectAll("rect")
                            .data(dataset)
                            .enter()
                            .append('rect')
                            .attr('x', (d, i) => d.col*10)
                            .attr('y', (d, i) => d.row*10)
                            .attr("width", 10)
                            .attr("height", 10)
                            .attr("fill", "green")
            
            
            
                        // Append the SVG element.
                        container.append(svg.node());
            
                        /*
                        // dimensions
                        var margin = {top: 20, right: 20, bottom: 30, left: 55},
                            svg_dx = 600, 
                            svg_dy = 600,
                            chart_dx = svg_dx - margin.right - margin.left,
                            chart_dy = svg_dy - margin.top - margin.bottom;
            
                        // data
                        var y = d3.randomNormal(400, 100);
                        var x_jitter = d3.randomUniform(-100, 1400);
            
                        var d = d3.range(1000)
                                    .map(function() { 
                                        return [x_jitter(), y()]; 
                                    });
            
                        // fill
                        var colorScale = d3.scaleLinear()
                                            .domain(d3.extent(d, function(d) { return d[1]; }))
                                            .range([0, 1]);
            
            
                        // y position
                        var yScale = d3.scaleLinear()
                                        .domain(d3.extent(d, function(d) { return d[1]; }))
                                        .range([chart_dy, margin.top]);
                        
                        // x position
                        var xScale = d3.scaleLinear()
                                        .domain(d3.extent(d, function(d) { return d[0]; }))
                                        .range([margin.right, chart_dx]);
            
                        // y-axis
                        var yAxis = d3.axisLeft(yScale);
            
                        // x-axis
                        var xAxis = d3.axisBottom(xScale);
            
                        // append svg to div element 'reg_plot' and set zoom to our function named 'zoom'
                        var svg = d3.select("#reg_plot")
                                    .append("svg")
                                    .attr("width", svg_dx)
                                    .attr("height", svg_dy);
                        svg.call(d3.zoom().on("zoom", zoom));
            
                        // clip path - sets boundaries so points will not show outside of the axes when zooming/panning
                        var clip = svg.append("defs").append("svg:clipPath")
                        .attr("id", "clip")
                        .append("svg:rect")
                        .attr("id", "clip-rect")
                        .attr("x", "0")
                        .attr("y", "0")
                        .attr('width', chart_dx)
                        .attr('height', chart_dy);
            
                        // plot data
                        var circles = svg.append("g")
                                        .attr("id", "circles")
                                        .attr("transform", "translate(75, 0)")
                                        .attr("clip-path", "url(#clip)")
                                        .selectAll("circle")
                                        .data(d)
                                        .enter()
                                        .append("circle")
                                        .attr("r", 4)
                                        .attr("cx", function(d) { return xScale(d[0]); })
                                        .attr("cy", function(d) { return yScale(d[1]); })
                                        .style("fill", function(d) { 
                                            var norm_color = colorScale(d[1]);
                                            return d3.interpolateInferno(norm_color) 
                                        });
            
                        // add y-axis
                        var y_axis = svg.append("g")
                                        .attr("id", "y_axis")
                                        .attr("transform", "translate(75,0)")
                                        .call(yAxis).style("font-size", "10px")
                                    
                        // add x-axis
                        var x_axis = svg.append("g")
                                        .attr("id", "x_axis")
                                        .attr("transform", `translate(${margin.left}, ${svg_dy - margin.bottom - margin.top})`)
                                        .call(xAxis).style("font-size", "10px")
                        
                        // add x and y grid lines
                        x_axis.call(xAxis.scale(xScale).ticks(20).tickSize(-chart_dy));
                        y_axis.call(yAxis.scale(yScale).ticks(20).tickSize(-chart_dx));
                        */
            
                        /*
                        function zoom(e) {
                            // re-scale y axis during zoom
                            y_axis.transition()
                                    .duration(50)
                                    .call(yAxis.scale(e.transform.rescaleY(yScale)));
            
                            // re-scale x axis during zoom
                            x_axis.transition()
                                    .duration(50)
                                    .call(xAxis.scale(e.transform.rescaleX(xScale)));
            
                            // re-draw circles using new scales
                            var new_xScale = e.transform.rescaleX(xScale);
                            var new_yScale = e.transform.rescaleY(yScale);
            
                            // re-scale axes and gridlines
                            x_axis.call(xAxis.scale(new_xScale).ticks(20).tickSize(-chart_dy));
                            y_axis.call(yAxis.scale(new_yScale).ticks(20).tickSize(-chart_dx));
                            circles.data(d)
                                .attr('cx', function(d) {return new_xScale(d[0])})
                                .attr('cy', function(d) {return new_yScale(d[1])});                
                        }
                        */
            }
          },
          /* /Actions */
          /* Commands */
          commands: {
            "launch" : function(){
            	simplyApp.actions.launch()
              	console.log("bla")
            }
          },
          /* /Commands */
          /* Keyboard shortcuts */
          keyboard: {
            
          },
          /* /Keyboard shortcuts */
          /* Routes */
          routes: {
            "/" : function() {
              editor.pageData.page = 'MainPage'
            }
          }
          /* /Routes */
        });
      });
      function clone(ob) {
        return JSON.parse(JSON.stringify(ob));
      }
      function updateDataSource(name) {
        document.querySelectorAll('[data-simply-data="'+name+'"]').forEach(function(list) {
          editor.list.applyDataSource(list, name);
          list.dataBindingPaused = 0;
        });
      }
    </script>
  </head>
  <body>
    <!-- Body HTML -->
    <!-- life -->
    
    <!-- /Body HTML -->
    <!-- Component HTML templates -->
    <template id="CurrentPlayer">
      <div>
      <h1>Current player</h1>
      <h2>Name: Hoxolotl</h2>
      
      <h3>Score: total score: 100050 px</h3>
      <h3>Score: current point budget: 15001 px </h3>
      
      <h3 class="player-color">Player color</h3>
    </div>
    </template>
    <template id="Main">
      <h1>AMPF</h1>
    <span>Awesome Multiplayer Pixel Flyer</span>
    <simply-render rel="GOLM"> </simply-render>
    </template>
    <template id="ShipLibrary">
      <div>
      <h1>Ship Library</h1>
      
      
      <button> Edit ship library </button>
    </div>
    </template>
    <template id="gol">
      <h1>Game of life</h1>
    <div id="GOLMap"></div>
    <button data-command="increase">+</button>
    <button data-command="play">►</button>
    <button data-command="stop">■</button>
    
    </template>
    <template id="GOLM">
      
    
     <h1>Well this is:</h1>
    <div class="GOLMap"></div>
    
    
    <script class="source" type="module">
        import {signal, effect, batch} from '/js/simplyflow/src/state.mjs'
    	import {bind} from '/js/simplyflow/src/bind.mjs'
    	import {model, paging, sort, filter, columns, scroll} from '/js/simplyflow/src/model.mjs'
        
      	let GOLMap = document.querySelector(".GOLMap");
    	console.log("GOL MAPS: ", GOLMap)
      
       //document.getElementById('GOLMap').innerHTML = "BOOOTS!"
        let GOLMapGrid = ""
    	
        GOLMap.innerHTML = "HERE WILL BE A MAP"
            
    </script>
    </template>
    <!-- /Component HTML templates -->
    <div class="main" data-simply-field="page" data-simply-content="template">
    <!-- Page HTML templates -->
    <template data-simply-template="MainPage">
      <div class="grid-container">
      <div class="column-left">
        <simply-render rel="ShipLibrary"></simply-render>
      </div>
      <div class="column-center">
    	<simply-render rel="Main"></simply-render>
      </div>
      <div class="column-right">
        <simply-render rel="CurrentPlayer"></simply-render>
      </div>
    </div>
    </template>
    <!-- /Page HTML templates -->
    </div>
    <script src="js/simply.everything.js"></script>
    <script src="js/simply-edit.js" data-simply-storage="none" data-api-key="muze"></script>
    <script>
      /* Transformers */
      editor.transformers = {
        
      };
      /* /Transformers */
    </script>
    <script>
      /* Sorters */
      editor.sorters = {
        
      };
      /* /Sorters */
    </script>
    <script>
      window.addEventListener("simply-content-loaded", function() {
        /* Data sources */
        
        /* /Data sources */
      });
    </script>
    <!-- Foot HTML -->
    <!-- life -->
    <script type="module" >
      import { signal, effect, clockEffect } from 'https://cdn.jsdelivr.net/gh/poef/signals/src/signals.mjs'
      
    // this class represents a single cell in a game of life matrix
    	// it doesn't know its own position or the size of the board
    	// it only knows which cells are its neighbours
    	class Cell {
    
    		constructor(alive, renderClock, calcClock) {
    			// setup state as a signal
    			this.state = signal({
    				alive: !!alive,
    				neighbours: []
    			})
    			// so that effects are triggered on state change
    			// first add an effect that calculates the next state
    			// but only when the calcClock changes
    			// so that we don't trigger cyclical dependencies
    			// we cannot change the state.alive here, since that
    			// would immediately influence the next state for each
    			// neighbour, so the next board state could never be
    			// calculated
    			clockEffect(() => {
    				let neighbourCount = this.state.neighbours
    					.filter(nb => nb.state.alive)
    					.length
    				if (this.state.alive) {
    					this.state.next = neighbourCount == 2 || neighbourCount == 3
    				} else {
    					this.state.next = neighbourCount == 3
    				}
    			}, calcClock)
    			// than add an effect that sets the current state
    			// to the next state, and resets the next state
    			// but on a separate renderClock
    			// so that we can do all the next state calculations first
    			// and only then move the state
    			clockEffect(() => {
    				this.state.alive = this.state.next
    				this.state.next = null // make sure that next calculation triggers change
    				// if you don't update the next state, some cells won't
    				// be re-calculated in the next renderClock step
    			}, renderClock)
    		}
    		
    		// because cells have a cyclical graph structure
    		// we must be able to first create all cells
    		// and then update each cells neighbours
    		setNeighbours(neighbours) {
    			this.state.neighbours = neighbours
    		}
    
    		// use dom createElement to add each checkbox
    		// so that we can attach event listeners and effects to it
    		render() {
    			// render each cell as a checkbox input
    			// where a cell that is alive, is checked
    			let checkbox = document.createElement('input')
    			checkbox.type = 'checkbox'
    
    			// this updates the current cells state.alive when
    			// you click the checkbox. Don't do this onchange
    			// because that event will also trigger when we
    			// change the checkbox.checked in an effect
    			checkbox.addEventListener('click', evt => {
    				this.state.alive = !!checkbox.checked
    			})
    
    			// this effect is triggered whenever state.alive changes
    			// and immediately updates the checkbox checked state to follow
    			effect(() => {
    				let checked = this.state.alive ? 'checked' : ''
    				checkbox.checked = checked
    			})
    			
    			// add checked checkbox to data
    
    			// return the checkbox, to let the board render it
    			return checkbox
    		}
    	}
    
    	// this class renders a board of cells, you can specify the size
    	// of the board
    	// the board will tell each Cell who its neighbours are
    	export class Board {
    
    		// boardSize is an array of [x,y]
    		// renderClock and calcClock are passed to each cell
    		constructor(boardSize, renderClock, calcClock) {
    			this.size = boardSize
    			this.rows = []
    			// create all cells
    			for (let y=0; y<this.size[1]; y++) {
    				let row = []
    				for (let x=0; x<this.size[0]; x++) {
    					row[x] = new Cell(false, renderClock, calcClock)
    				}
    				this.rows[y] = row
    			}
    			// then find each cells neighbours and set those
    			const offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
    			for (let y=0; y<this.size[1];y++) {
    				for (let x=0; x<this.size[0];x++) {
    					let neighbours = offsets
    						.map(([dx,dy]) => this.rows[y+dy]?.[x+dx]) // retrieve cells based on each offset
    						.filter(Boolean) // remove null / undefined cells
    					this.rows[y][x].setNeighbours(neighbours)
    				}
    			}
    		}
    
    		// renders a table with a Cell in each td
    		// each cell will update itself, so we only need to render this once
    		render() {
    			let table = document.createElement('table')
    			let y = 0
    			for (let row of this.rows) {
    				let tr = document.createElement('tr')
    				let x = 0
    				for (let cell of row) {
    					let td = document.createElement('td')
    					td.appendChild(cell.render(x,y))
    					tr.appendChild(td)
    					x++
    				}
    				table.appendChild(tr)
    				y++
    			}
    			return table
    		}
    	}
    
    	// setup the global calcClock and renderClock
    	const calcClock = signal({
    		time: 0
    	})
    	const renderClock = signal({
    		time: 0
    	})
    	// initialize the board
    	const boardEl = document.getElementById('oldboard')
    	const boardSize = [32,32]
    	const board = new Board(boardSize, renderClock, calcClock)
    	boardEl.appendChild(board.render())
    
    	// add a handler to increase the clock times for both clocks, in order
    	document.querySelectorAll('[data-command="increase"]').forEach(el => {
    		el.addEventListener('click', (evt) => {
    			calcClock.time++
    			renderClock.time++
    			evt.preventDefault()
    		})
    	})
      
    	// add a way to save table state:
    	function getCheckedCoordinatesCSS() {
    		const checkedBoxes = []; 
    		const table = document.getElementById('oldboard'); 
    		const allChecked = table.querySelectorAll('input[type="checkbox"]:checked'); 
    		allChecked.forEach(checkbox => { 
    			const cell = checkbox.closest('td'); 
    			const row = cell.parentNode.rowIndex; 
    			const col = cell.cellIndex; 
    			checkedBoxes.push({ 
    				row: row, col: col, coordinates: `(${row}, ${col})`,  playerColor: 'green', playerName: 'Hoxolotl'
    			}); 
    		}); 
    		console.log("these", checkedBoxes);
    		simply.app.life = checkedBoxes;
    	}
    
    
    
      // playing
      
      let playstate = false
      
      function renderfield(){
    			getCheckedCoordinatesCSS()
           		calcClock.time++
    			renderClock.time++
        		console.log("one step!")
    			
      }
      
      document.querySelectorAll('[data-command="stop"]').forEach(el => {
          	el.addEventListener('click', (evt) => {
              if(playstate){
              	clearInterval(playstate)
                playstate = false
              }
    		})
    	})
        
      	// add a handler to increase the clock times for both clocks, in order
    	document.querySelectorAll('[data-command="play"]').forEach(el => {
          	el.addEventListener('click', (evt) => {
             	if(!playstate){
    				playstate = setInterval(renderfield, 500)
                }        
    		})
    	})
    </script>
    <!-- signals -->
    
    <!-- /Foot HTML -->
  </body>
</html>